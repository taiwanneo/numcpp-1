/* [[[cog

# :mode=python:

import cog
import cog_warning

cog_warning.warn(cog, __COGFILE__, prefix = '//')
]]] */
// [[[end]]]

#ifndef _NUMCPP_ARRAY_HPP_
    #error "only <numcpp/array.hpp> can include this file!"
#endif


//-----------------------------------------------------------------------------
// unary operators
//
//     /*operator+*/
//     operator-
//     operator~
//     operator!

/* [[[cog

import cog

template = '''
template <class R>
array<{return_type}>
array<R>::
operator{op}() const
{{
    DOUT << __PRETTY_FUNCTION__ << std::endl;

    array<R> out;

    out._size = _size;
    out._array = std::make_shared<std::vector<R>>();
    out._array->reserve(_size);
    out._shape = _shape;

    if(ndim() == 1)
    {{
        #define loop( idx )                                                 \\
            for(std::size_t i = 0; i < _size; ++i)                          \\
            {{                                                               \\
                out._array->emplace_back({op}(*_array)[_offset + idx ]);       \\
            }}

        if(_strides.empty()) loop( i )
        else                 loop( i * _strides[0] )

        #undef loop

        return out;
    }}
    else
    if(ndim() == 2)
    {{
        out.reshape(_shape);

        #define loop( idx )                                                 \\
        {{                                                                   \\
            for(std::size_t m = 0; m < _shape[0]; ++m)                      \\
            {{                                                               \\
                for(std::size_t n = 0; n < _shape[1]; ++n)                  \\
                {{                                                           \\
                    out._array->emplace_back({op}(*_array)[_offset + idx]);    \\
                }}                                                           \\
            }}                                                               \\
        }}

        if(_strides.empty()) loop( m * _shape[1] + n )
        else                 loop( m * _strides[0] + n * _strides[1] )

        #undef loop

        return out;
    }}

    M_THROW_RT_ERROR("unhandled case"); // LCOV_EXCL_LINE

    return out; // LCOV_EXCL_LINE
}}

'''

gen_ops = (
#~    ('+', 'R'),
    ('-', 'R'),
    ('~', 'R'),
    ('!', 'bool'),
)

for op, return_type in gen_ops:

    code = template.format(op = op, return_type = return_type)

    cog.out(code)


]]] */
// [[[end]]]


//-----------------------------------------------------------------------------
// array operators
//
//     operator+=   (const array<R> &)
//     operator-=   (const array<R> &)
//     operator*=   (const array<R> &)
//     operator/=   (const array<R> &)
//     operator%=   (const array<R> &)
//     operator&=   (const array<R> &)
//     operator|=   (const array<R> &)
//     operator^=   (const array<R> &)
//     operator<<=  (const array<R> &)
//     operator>>=  (const array<R> &)

/* [[[cog

import cog

template = '''
template <class R>
array<R> &
array<R>::
operator{op}(const array<R> & rhs)
{{
    DOUT << __PRETTY_FUNCTION__ << std::endl;

    if(ndim() == 1)
    {{
        #define loop( idx )                                 \\
            for(std::size_t i = 0; i < _size; ++i)          \\
            {{                                               \\
                (*_array)[_offset + idx ] {op} rhs(i);        \\
            }}

        if(_strides.empty()) loop( i )
        else                 loop( i * _strides[0] )

        #undef loop

        return *this;
    }}
    else
    if(ndim() == 2)
    {{
        #define loop( idx )                                                 \\
        {{                                                                   \\
            for(std::size_t m = 0; m < _shape[0]; ++m)                      \\
            {{                                                               \\
                for(std::size_t n = 0; n < _shape[1]; ++n)                  \\
                {{                                                           \\
                    (*_array)[_offset + idx] {op} rhs(m,n);                   \\
                }}                                                           \\
            }}                                                               \\
        }}

        if(_strides.empty()) loop( m * _shape[1] + n )
        else                 loop( m * _strides[0] + n * _strides[1] )

        #undef loop

        return *this;
    }}
    else
    if(ndim() == 3)
    {{
        #define loop( idx )                                                 \\
        {{                                                                   \\
            for(std::size_t m = 0; m < _shape[0]; ++m)                      \\
            {{                                                               \\
                for(std::size_t n = 0; n < _shape[1]; ++n)                  \\
                {{                                                           \\
                    for(std::size_t p = 0; p < _shape[2]; ++p)              \\
                    {{                                                       \\
                        (*_array)[_offset + idx] {op} rhs(m,n, p);            \\
                    }}                                                       \\
                }}                                                           \\
            }}                                                               \\
        }}

        if(_strides.empty()) loop( m * _shape[1] * _shape[2] + n * _shape[2] + p )
        else                 loop( m * _strides[0] + n * _strides[1] + p * _strides[2] )

        #undef loop

        return *this;
    }}

    M_THROW_RT_ERROR("unhandled case"); // LCOV_EXCL_LINE

    return *this; // LCOV_EXCL_LINE
}}

'''

gen_ops = '+= -= *= /= %= &= |= ^= <<= >>='.split()

for op in gen_ops:

    code = template.format(op = op)

    cog.out(code)

]]] */
// [[[end]]]


//-----------------------------------------------------------------------------
// array operators
//
//     operator+=   (const R &)
//     operator-=   (const R &)
//     operator*=   (const R &)
//     operator/=   (const R &)
//     operator%=   (const R &)
//     operator&=   (const R &)
//     operator|=   (const R &)
//     operator^=   (const R &)
//     operator<<=  (const R &)
//     operator>>=  (const R &)

/* [[[cog

import cog

template = '''
template <class R>
array<R> &
array<R>::
operator{op}(const R & rhs)
{{
    DOUT << __PRETTY_FUNCTION__ << std::endl;

    if(ndim() == 1)
    {{
        #define loop( idx )                                 \\
            for(std::size_t i = 0; i < _size; ++i)          \\
            {{                                               \\
                (*_array)[_offset + idx ] {op} rhs;           \\
            }}

        if(_strides.empty()) loop( i )
        else                 loop( i * _strides[0] )

        #undef loop

        return *this;
    }}
    else
    if(ndim() == 2)
    {{
        #define loop( idx )                                                 \\
        {{                                                                   \\
            for(std::size_t m = 0; m < _shape[0]; ++m)                      \\
            {{                                                               \\
                for(std::size_t n = 0; n < _shape[1]; ++n)                  \\
                {{                                                           \\
                    (*_array)[_offset + idx] {op} rhs;                        \\
                }}                                                           \\
            }}                                                               \\
        }}

        if(_strides.empty()) loop( m * _shape[1] + n )
        else                 loop( m * _strides[0] + n * _strides[1] )

        #undef loop

        return *this;
    }}
    else
    if(ndim() == 3)
    {{
        #define loop( idx )                                                \\
        {{                                                                  \\
            for(std::size_t m = 0; m < _shape[0]; ++m)                     \\
            {{                                                              \\
                for(std::size_t n = 0; n < _shape[1]; ++n)                 \\
                {{                                                          \\
                    for(std::size_t p = 0; p < _shape[2]; ++p)             \\
                    {{                                                      \\
                        (*_array)[_offset + idx] {op} rhs;                   \\
                    }}                                                      \\
                }}                                                          \\
            }}                                                              \\
        }}

        if(_strides.empty()) loop( m * _shape[1] * _shape[2] + n * _shape[2] + p )
        else                 loop( m * _strides[0] + n * _strides[1] + p * _strides[2] )

        #undef loop

        return *this;
    }}

    M_THROW_RT_ERROR("unhandled case"); // LCOV_EXCL_LINE

    return *this; // LCOV_EXCL_LINE
}}

'''

gen_ops = '+= -= *= /= %= &= |= ^= <<= >>='.split()

for op in gen_ops:

    code = template.format(op = op)

    cog.out(code)

]]] */
// [[[end]]]


//-----------------------------------------------------------------------------
// array operators
//
//     operator+
//     operator-
//     operator*
//     operator/
//     operator%
//     operator&
//     operator|
//     operator^
//     operator<<
//     operator>>

/* [[[cog

import cog

template = '''
template <class R>
array<R>
operator{op}(const array<R> & lhs, const R & rhs)
{{
    DOUT << __PRETTY_FUNCTION__ << std::endl;

    array<R> out(lhs);

    out {op}= rhs;

    return out;
}}


template <class R>
array<R>
operator{op}(const R & lhs, const array<R> & rhs)
{{
    DOUT << __PRETTY_FUNCTION__ << std::endl;

    array<R> out(R(), rhs.shape());

    if(out.ndim() == 1)
    {{
        for(std::size_t i = 0; i < out.size(); ++i)
        {{
            R tmp = R{{lhs}};
            tmp {op}= rhs(i);
            out(i) = tmp;
        }}

        return out;
    }}
    else
    if(out.ndim() == 2)
    {{
        for(std::size_t m = 0; m < out.shape()[0]; ++m)
        {{
            for(std::size_t n = 0; n < out.shape()[1]; ++n)
            {{
                R tmp = R{{lhs}};
                tmp {op}= rhs(m,n);
                out(m,n) = tmp;
            }}
        }}

        return out;
    }}
    else
    if(out.ndim() == 3)
    {{
        for(std::size_t m = 0; m < out.shape()[0]; ++m)
        {{
            for(std::size_t n = 0; n < out.shape()[1]; ++n)
            {{
                for(std::size_t p = 0; p < out.shape()[2]; ++p)
                {{
                    R tmp = R{{lhs}};
                    tmp {op}= rhs(m,n,p);
                    out(m,n,p) = tmp;
                }}
            }}
        }}

        return out;
    }}

    M_THROW_RT_ERROR("unhandled case"); // LCOV_EXCL_LINE

    return out; // LCOV_EXCL_LINE
}}


template <class R>
array<R>
operator{op}(const array<R> & lhs, const array<R> & rhs)
{{
    DOUT << __PRETTY_FUNCTION__ << std::endl;

    if(lhs.shape() != rhs.shape())
    {{
        M_THROW_RT_ERROR("operands could not be broadcast together with shapes " << lhs.shape() << " " << rhs.shape());
    }}

    array<R> out(lhs);

    out {op}= rhs;

    return out;
}}

'''

gen_ops = '+ - * / % & | ^ << >>'.split()

for op in gen_ops:

    code = template.format(op = op)

    cog.out(code)

]]] */
// [[[end]]]